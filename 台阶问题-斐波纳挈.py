# 1、一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

# 如果n<=2 就返回n
# 如果n > 2 就递归调用

# 其实不管它跳多少次，结果都需要在1阶或者2阶选择，所以遇到像跳几阶的做法，先看它开始能跳几阶。
# 都可以用递归函数到最后在开始几阶中计算
# ===================
总结一下：
解题思路：
可以先列出几项出来，看有没有规律。
# ===================

# 如果是能跳到n阶实际上就是2*f(n-1)

# 假设fib(n)是n个台阶的次数
# fib(1) = 1
# fib(2) 会有两种跳法，1-1, 2
# fib(3)时，就有三种跳法， 1-1-1， 1-2， 2-1
# fib(4)时，就有5种跳法， 1-1-1-1， 1-2-1， 1-1-2， 1-2-1，2-1-1, 2-2

思路:
1===>1
2===>2
3===>3
4===>5
5===>8
6===>13
其实这里可以看到一个规律，就是后面的是前面两个是之和 
# ================================================================
# 方法1、
fib1 = lambda n : n if n <= 2 else fib1(n - 1) + fib1(n - 2)
# print(fib1(6))

# 相当于
def fib1(n):
	if n <=2 :
		return n
	return fib1(n - 1) + fib1(n - 2)

# ================================================================

# 方法2：装饰器方法
def memo(func):
	cache = {}
	def wrap(*args):
		if args not in cache:
			cache[args] = func(*args)
		return cache[args]	
	return wrap

@memo
def fib2(i):
	if i<2:
		return i
	return fib2(i - 1) + fib2(i - 2)

# ================================================================
# 由于后面是前面两个之和，那方法3就明了了
# 方法3：
def fib3(n):
	a, b = 0, 1
	for _ in range(n):
		a, b = b, a + b
	return b
# print(fib3(3))
# ================================================================

2、如果问题是一只青蛙它可以跳1阶，2阶，到n阶，求跳上n阶需要几种跳法
# 1==>1
# 2==>2
# 3==>4
# 4==>8
# 5==>16
# 可以看到，后面是前面一项的2倍

fib = lambda n: n if n < 2 else 2*fib(n-1)

# 相当于
def fib(n):
	if n < 2:
		return n
	return 2*fib(n-1)
print(fib(5))
